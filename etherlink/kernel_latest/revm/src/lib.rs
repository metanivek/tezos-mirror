// SPDX-FileCopyrightText: 2025 Functori <contact@functori.com>
// SPDX-FileCopyrightText: 2025 Nomadic Labs <contact@nomadic-labs.com>
//
// SPDX-License-Identifier: MIT

use crate::{database::PrecompileDatabase, send_outbox_message::Withdrawal};
use database::EtherlinkVMDB;
use precompile_provider::EtherlinkPrecompiles;
use revm::context::result::EVMError;
use revm::{
    context::{
        result::ExecutionResult, transaction::AccessList, BlockEnv, CfgEnv, ContextTr,
        DBErrorMarker, Evm, LocalContext, TxEnv,
    },
    context_interface::block::BlobExcessGasAndPrice,
    handler::instructions::EthInstructions,
    interpreter::interpreter::EthInterpreter,
    primitives::{hardfork::SpecId, Address, Bytes, FixedBytes, TxKind, U256},
    Context, ExecuteCommitEvm, Journal, MainBuilder,
};
use storage_helpers::u256_to_le_bytes;
use tezos_ethereum::block::BlockConstants;
use tezos_evm_runtime::runtime::Runtime;
use tezos_smart_rollup_host::runtime::RuntimeError;
use thiserror::Error;
use world_state_handler::{account_path, WorldStateHandler};

pub mod precompile_provider;
pub mod send_outbox_message;
pub mod world_state_handler;

mod block_storage;
mod code_storage;
mod database;
mod storage_helpers;

const ETHERLINK_CHAIN_ID: u64 = 42793;
const DEFAULT_SPEC_ID: SpecId = SpecId::PRAGUE;
const MAX_GAS_PER_TRANSACTION: u64 = 30_000_000;

#[derive(Error, Debug)]
pub enum Error {
    #[error("Runtime error: {0}")]
    Runtime(#[from] RuntimeError),
    #[error("Execution error: {0}")]
    Custom(String),
}

impl DBErrorMarker for Error {}

#[derive(Debug, Eq, PartialEq)]
pub struct ExecutionOutcome {
    /// Result of the VM transaction execution.
    /// In particular contains gas used and emitted logs.
    pub result: ExecutionResult,
    /// Withdrawals generated by the transaction. This field will be empty if the
    /// transaction fails (or if the transaction doesn't produce any withdrawals).
    pub withdrawals: Vec<Withdrawal>,
}

fn block_env(block_constants: &BlockConstants) -> Result<BlockEnv, Error> {
    // TODO: Whenever the switch to REVM is completely made, readapt BlockConstants
    // structure to match alloy's type. The current structure is highly dependant
    // on what is needed for Sputnik.
    let basefee: u64 = match block_constants.base_fee_per_gas().try_into() {
        Ok(basefee) => basefee,
        Err(err) => {
            return Err(Error::Custom(format!(
                "Invalid base fee per gas conversion: {err:?}"
            )))
        }
    };
    Ok(BlockEnv {
        number: U256::from_le_slice(&u256_to_le_bytes(block_constants.number)),
        beneficiary: Address::from(block_constants.coinbase.0),
        timestamp: U256::from_le_slice(&u256_to_le_bytes(block_constants.timestamp)),
        gas_limit: block_constants.gas_limit,
        basefee,
        difficulty: U256::ZERO,
        prevrandao: block_constants
            .prevrandao
            .map(|prevrandao| FixedBytes(prevrandao.0)),
        blob_excess_gas_and_price: Some(BlobExcessGasAndPrice::new(0, 1)),
    })
}

#[allow(clippy::too_many_arguments)]
fn tx_env<'a, Host: Runtime>(
    host: &'a mut Host,
    world_state_handler: &'a mut WorldStateHandler,
    caller: Address,
    destination: Option<Address>,
    gas_limit: u64,
    gas_price: u128,
    value: U256,
    data: Bytes,
    access_list: AccessList,
) -> Result<TxEnv, Error> {
    let kind = match destination {
        Some(address) => TxKind::Call(address),
        None => TxKind::Create,
    };

    let storage_account = world_state_handler
        .get_or_create(host, &account_path(&caller))
        .map_err(|err| Error::Custom(err.to_string()))?;
    let nonce = storage_account.nonce(host)?;

    Ok(TxEnv {
        tx_type: 2,
        caller,
        gas_limit,
        gas_price,
        kind,
        value,
        data,
        nonce,
        chain_id: Some(ETHERLINK_CHAIN_ID),
        access_list,
        gas_priority_fee: None,
        blob_hashes: vec![],
        max_fee_per_blob_gas: 0,
        authorization_list: vec![],
    })
}

type EvmContext<'a, Host> = Evm<
    Context<&'a BlockEnv, &'a TxEnv, CfgEnv, EtherlinkVMDB<'a, Host>>,
    (),
    EthInstructions<
        EthInterpreter,
        Context<&'a BlockEnv, &'a TxEnv, CfgEnv, EtherlinkVMDB<'a, Host>>,
    >,
    EtherlinkPrecompiles,
>;

fn evm<'a, Host: Runtime>(
    db: EtherlinkVMDB<'a, Host>,
    block: &'a BlockEnv,
    tx: &'a TxEnv,
    precompiles: EtherlinkPrecompiles,
) -> EvmContext<'a, Host> {
    let cfg = CfgEnv::new()
        .with_chain_id(ETHERLINK_CHAIN_ID)
        .with_spec(DEFAULT_SPEC_ID);

    let context: Context<
        BlockEnv,
        TxEnv,
        CfgEnv,
        EtherlinkVMDB<'a, Host>,
        Journal<EtherlinkVMDB<'a, Host>>,
        (),
        LocalContext,
    > = Context::new(db, DEFAULT_SPEC_ID);

    let evm = context
        .with_block(block)
        .with_tx(tx)
        .with_cfg(cfg)
        .build_mainnet();

    evm.with_precompiles(precompiles)
}

#[allow(clippy::too_many_arguments)]
pub fn run_transaction<'a, Host: Runtime>(
    host: &'a mut Host,
    block_constants: &'a BlockConstants,
    world_state_handler: &'a mut WorldStateHandler,
    precompiles: EtherlinkPrecompiles,
    caller: Address,
    destination: Option<Address>,
    call_data: Bytes,
    gas_limit: Option<u64>,
    effective_gas_price: u128,
    value: U256,
    access_list: AccessList,
) -> Result<ExecutionOutcome, EVMError<Error>> {
    let mut commit_status = true;
    let block_env = block_env(block_constants)?;
    let tx = tx_env(
        host,
        world_state_handler,
        caller,
        destination,
        gas_limit.unwrap_or(MAX_GAS_PER_TRANSACTION),
        effective_gas_price,
        value,
        call_data,
        access_list,
    )?;

    let db = EtherlinkVMDB::new(
        host,
        block_constants,
        world_state_handler,
        &mut commit_status,
    );

    let mut evm = evm(db, &block_env, &tx, precompiles);

    evm.db_mut().initialize_storage()?;

    let execution_result = evm.transact_commit(&tx)?;

    let withdrawals = evm.db_mut().take_withdrawals();

    if !evm.db_mut().commit_status() {
        // If something went wrong while commiting we drop the state changes
        // made to the durable storage to avoid ending up in inconsistent state.
        evm.db_mut().drop_storage()?;

        return Err(EVMError::Custom(
            "Comitting ended up in an incorrect state change: reverting.".to_owned(),
        ));
    } else {
        evm.db_mut().commit_storage()?;
    }

    Ok(ExecutionOutcome {
        result: execution_result, // contains logs and gas_used.
        withdrawals,
    })
}

#[cfg(test)]
mod test {
    use primitive_types::{H160 as PH160, U256 as PU256};
    use revm::{
        context::{
            result::ExecutionResult, transaction::AccessList, BlockEnv, CfgEnv,
            ContextTr, LocalContext, TxEnv,
        },
        context_interface::block::BlobExcessGasAndPrice,
        inspector::inspectors::GasInspector,
        primitives::{hex::FromHex, Address, Bytes, FixedBytes, TxKind, U256},
        state::{AccountInfo, Bytecode},
        Context, Database, ExecuteCommitEvm, ExecuteEvm, Journal, MainBuilder,
    };
    use tezos_ethereum::block::{BlockConstants, BlockFees};
    use tezos_evm_runtime::runtime::MockKernelHost;
    use utilities::{block_env, etherlink_vm_db, evm, tx_env};

    use crate::{
        database::{EtherlinkVMDB, PrecompileDatabase},
        precompile_provider::EtherlinkPrecompiles,
        send_outbox_message::SEND_OUTBOX_MESSAGE_PRECOMPILE_ADDRESS,
    };
    use crate::{
        send_outbox_message::SendWithdrawalInput,
        world_state_handler::new_world_state_handler,
    };

    mod utilities {
        use revm::{
            context::Evm,
            handler::{instructions::EthInstructions, EthPrecompiles},
            interpreter::interpreter::EthInterpreter,
        };

        use crate::{DEFAULT_SPEC_ID, ETHERLINK_CHAIN_ID};

        use super::*;

        pub(crate) fn block_env(number: Option<U256>, gas_limit: u64) -> BlockEnv {
            BlockEnv {
                number: number.unwrap_or(U256::from(1)),
                beneficiary: Address::ZERO,
                timestamp: U256::from(0),
                gas_limit,
                basefee: 0,
                difficulty: U256::ZERO,
                prevrandao: Some(FixedBytes::new([0; 32])),
                blob_excess_gas_and_price: Some(BlobExcessGasAndPrice::new(0, 1)),
            }
        }

        pub(crate) fn tx_env(
            caller: Address,
            destination: Option<Address>,
            gas_limit: u64,
            gas_price: u128,
            value: U256,
            data: Bytes,
            nonce: Option<u64>,
        ) -> TxEnv {
            let kind = match destination {
                Some(address) => TxKind::Call(address),
                None => TxKind::Create,
            };

            TxEnv {
                tx_type: 2,
                caller,
                gas_limit,
                gas_price,
                kind,
                value,
                data,
                nonce: nonce.unwrap_or_default(),
                chain_id: Some(ETHERLINK_CHAIN_ID),
                access_list: AccessList(vec![]),
                gas_priority_fee: None,
                blob_hashes: vec![],
                max_fee_per_blob_gas: 0,
                authorization_list: vec![],
            }
        }

        pub(crate) fn block_constants(block_env: &BlockEnv) -> BlockConstants {
            BlockConstants::first_block(
                PU256::from_little_endian(block_env.number.as_le_slice()),
                PU256::from(1),
                BlockFees::new(
                    PU256::from(1),
                    PU256::from(block_env.basefee),
                    PU256::from(1),
                ),
                block_env.gas_limit,
                PH160::from(block_env.beneficiary.into_array()),
            )
        }

        pub(crate) fn etherlink_vm_db<'a>(
            commit_status: Option<bool>,
            block_env: &BlockEnv,
        ) -> EtherlinkVMDB<'a, MockKernelHost> {
            let commit_status = Box::leak(Box::new(commit_status.unwrap_or(true)));
            let host = Box::leak(Box::new(MockKernelHost::default()));
            let world_state_handler =
                Box::leak(Box::new(new_world_state_handler().unwrap()));
            let block_constants = Box::leak(Box::new(block_constants(block_env)));

            EtherlinkVMDB::new(host, block_constants, world_state_handler, commit_status)
        }

        type EvmContext<'a> = Evm<
            Context<&'a BlockEnv, &'a TxEnv, CfgEnv, EtherlinkVMDB<'a, MockKernelHost>>,
            (),
            EthInstructions<
                EthInterpreter,
                Context<
                    &'a BlockEnv,
                    &'a TxEnv,
                    CfgEnv,
                    EtherlinkVMDB<'a, MockKernelHost>,
                >,
            >,
            EthPrecompiles,
        >;

        pub(crate) fn evm<'a>(
            db: EtherlinkVMDB<'a, MockKernelHost>,
            block: &'a BlockEnv,
            tx: &'a TxEnv,
        ) -> EvmContext<'a> {
            let cfg = CfgEnv::new()
                .with_chain_id(ETHERLINK_CHAIN_ID)
                .with_spec(DEFAULT_SPEC_ID);

            let context: Context<
                BlockEnv,
                TxEnv,
                CfgEnv,
                EtherlinkVMDB<'a, MockKernelHost>,
                Journal<EtherlinkVMDB<'a, MockKernelHost>>,
                (),
                LocalContext,
            > = Context::new(db, DEFAULT_SPEC_ID);

            context
                .with_block(block)
                .with_tx(tx)
                .with_cfg(cfg)
                .build_mainnet()
        }
    }

    #[test]
    fn test_outbox_precompile_contract() {
        // import reexported version to build `SendWithdrawalInput`
        use alloy_sol_types::{sol_data::FixedBytes, SolEvent, SolType};

        let caller =
            Address::from_hex("1111111111111111111111111111111111111111").unwrap();
        let destination =
            Address::from_hex(SEND_OUTBOX_MESSAGE_PRECOMPILE_ADDRESS).unwrap();
        let value = U256::from(5);

        let mut abi_data = [0u8; 32];
        abi_data[0] = 0x01;
        abi_data[1..21].fill(0x11);
        abi_data[22] = 0x00;
        let fixed = FixedBytes::<22>::abi_decode(&abi_data, true).unwrap();
        let input = SendWithdrawalInput {
            target: fixed,
            ticketer: fixed,
            amount: U256::from(42),
        }
        .encode_data();
        let mut data = Vec::with_capacity(1 + input.len());
        data.extend_from_slice(&[0x0c, 0x22, 0xd2, 0x8f]);
        data.extend_from_slice(&input);

        let block = block_env(None, 1_000_000);
        let tx = tx_env(
            caller,
            Some(destination),
            block.gas_limit,
            0,
            value,
            Bytes::from(data),
            None,
        );

        let mut db = etherlink_vm_db(None, &block);

        let account_info = AccountInfo {
            balance: U256::MAX,
            nonce: 0,
            code_hash: Default::default(),
            code: None,
        };

        db.insert_account_info(caller, account_info);

        let evm = evm(db, &block, &tx);
        let tracer = GasInspector::default();
        let precompiles = EtherlinkPrecompiles::new();
        let mut evm = evm.with_inspector(tracer).with_precompiles(precompiles);
        let execution_result: ExecutionResult = evm.transact(&tx).unwrap();
        let withdrawals = evm.db_mut().take_withdrawals();

        assert!(execution_result.is_success());
        assert!(!withdrawals.is_empty());
    }

    #[test]
    fn test_simple_transfer() {
        let caller =
            Address::from_hex("1111111111111111111111111111111111111111").unwrap();
        let destination =
            Address::from_hex("2222222222222222222222222222222222222222").unwrap();
        let value = U256::from(5);

        let block = block_env(None, 1_000_000);
        let tx = tx_env(
            caller,
            Some(destination),
            block.gas_limit,
            0,
            value,
            Bytes::new(),
            None,
        );

        let mut db = etherlink_vm_db(None, &block);

        let account_info = AccountInfo {
            balance: U256::MAX,
            nonce: 0,
            code_hash: Default::default(),
            code: None,
        };

        db.insert_account_info(caller, account_info);

        let mut evm = evm(db, &block, &tx);

        let account_caller_pre_tx = evm.db_mut().basic(caller).unwrap().unwrap();
        let account_destination_pre_tx =
            evm.db_mut().basic(destination).unwrap().unwrap();

        // Check balances before executing the transfer
        assert_eq!(account_caller_pre_tx.balance, U256::MAX);
        assert_eq!(account_destination_pre_tx.balance, U256::ZERO);

        let execution_result = evm.transact_commit(&tx).unwrap();

        // Check the outcome of the transaction
        match execution_result {
            ExecutionResult::Success { .. } => (),
            ExecutionResult::Revert { .. } | ExecutionResult::Halt { .. } => {
                panic!("Simple transfer should have succeeded")
            }
        }

        // Check balances after executing the transfer
        let account_caller_post_tx = evm.db_mut().basic(caller).unwrap().unwrap();
        let account_destination_post_tx =
            evm.db_mut().basic(destination).unwrap().unwrap();

        assert_eq!(
            account_caller_post_tx.balance,
            U256::MAX.checked_sub(value).unwrap()
        );
        assert_eq!(account_destination_post_tx.balance, value);
    }

    #[test]
    fn test_contract_call_sload_sstore() {
        let caller =
            Address::from_hex("1111111111111111111111111111111111111111").unwrap();
        let contract =
            Address::from_hex("2222222222222222222222222222222222222222").unwrap();

        let block = block_env(None, 10_000_000);
        let tx = tx_env(
            caller,
            Some(contract),
            block.gas_limit,
            10,
            U256::from(0),
            Bytes::new(),
            None,
        );

        let mut db = etherlink_vm_db(None, &block);

        let caller_info = AccountInfo {
            balance: U256::MAX,
            nonce: 0,
            code_hash: Default::default(),
            code: None,
        };

        let contract_info = AccountInfo {
            balance: U256::ZERO,
            nonce: 0,
            // Code hash will be automatically computed and inserted when
            // inserting the account info into the db.
            code_hash: Default::default(),
            // PUSH1 0x42      # Value to store
            // PUSH1 0x01      # Storage slot index
            // SSTORE          # Store the value in storage
            // PUSH1 0x01      # Load from the same storage slot
            // SLOAD           # Retrieve the value
            code: Some(Bytecode::new_raw(
                Bytes::from_hex("6042600155600154").unwrap(),
            )),
        };

        db.insert_account_info(caller, caller_info);
        db.insert_account_info(contract, contract_info);

        let mut evm = evm(db, &block, &tx);

        let execution_result = evm.transact_commit(&tx).unwrap();

        // Check the outcome of the transaction
        match execution_result {
            ExecutionResult::Success { gas_used, .. } => {
                assert!(gas_used > 0);
            }
            ExecutionResult::Revert { .. } | ExecutionResult::Halt { .. } => {
                panic!("Simple transfer should have succeeded")
            }
        }

        // Check that the storage slot at 0x01 was updated with 0x42
        let storage_slot_value = evm.db().storage_slot(contract, U256::from(1));
        assert_eq!(storage_slot_value, U256::from(66));
    }
}
