// SPDX-FileCopyrightText: 2025 Functori <contact@functori.com>
//
// SPDX-License-Identifier: MIT

//! Tezos operations

/// The whole module is inspired of `src/proto_alpha/lib_protocol/apply_result.ml` to represent the result of an operation
/// In Tezlink, operation is equivalent to manager operation because there is no other type of operation that interests us.
use nom::error::ParseError;
use std::fmt::Debug;
use tezos_crypto_rs::hash::ContractKt1Hash;
use tezos_crypto_rs::hash::UnknownSignature;
use tezos_data_encoding::enc as tezos_enc;
use tezos_data_encoding::nom as tezos_nom;
use tezos_data_encoding::nom::error::DecodeError;
use tezos_data_encoding::types::Narith;
use tezos_data_encoding::types::Zarith;
use tezos_enc::BinWriter;
use tezos_nom::NomReader;
use tezos_smart_rollup::types::Contract;
use tezos_smart_rollup::types::{PublicKey, PublicKeyHash};
use tezos_smart_rollup_host::runtime::RuntimeError;
use thiserror::Error;

use crate::operation::OriginationContent;
use crate::operation::{
    ManagerOperation, ManagerOperationContent, OperationContent, RevealContent,
    TransferContent,
};

#[derive(Debug, PartialEq, Eq, NomReader, BinWriter)]
pub struct CounterError {
    pub expected: Narith,
    pub found: Narith,
}

#[derive(Error, Debug, PartialEq, Eq, NomReader, BinWriter)]
pub enum ValidityError {
    #[error("Counter in the past: {0:?}.")]
    CounterInThePast(CounterError),
    #[error("Counter in the future: {0:?}.")]
    CounterInTheFuture(CounterError),
    #[error("Missing manager contract.")]
    MissingManagerContract,
    #[error("The manager key for {0} has not been revealed yet.")]
    UnrevealedManagerKey(PublicKeyHash),
    #[error("Cannot pay {0:?} in fees.")]
    CantPayFees(Narith),
    #[error("Empty implicit contract.")]
    EmptyImplicitContract,
    #[error("Gas limit is too high.")]
    GasLimitTooHigh,
    #[error("Storage limit is too high.")]
    StorageLimitTooHigh,
    #[error("Invalid signature.")]
    InvalidSignature,
    #[error("Failed to fetch account")]
    FailedToFetchAccount,
    #[error("Failed to compute fee balance update")]
    FailedToComputeFeeBalanceUpdate,
    #[error("Failed to fetch counter")]
    FailedToFetchCounter,
    #[error("Failed to fetch manager key")]
    FailedToFetchManagerKey,
    #[error("Failed to fetch balance")]
    FailedToFetchBalance,
    #[error("Failed to update balance")]
    FailedToUpdateBalance,
    #[error("Failed to increment counter.")]
    FailedToIncrementCounter,
    #[error("Batch is empty.")]
    EmptyBatch,
    #[error("Batch contains operations from multiple sources.")]
    MultipleSources,
}

#[derive(Error, Debug, PartialEq, Eq, NomReader, BinWriter)]
pub enum RevealError {
    #[error("Revelation failed because the public key {0} was already revealed.")]
    PreviouslyRevealedKey(PublicKey),
    #[error("The public key hash {0} is inconsistent.")]
    InconsistentHash(PublicKeyHash),
    #[error("The public key hash {0} is inconsistent with the public key provided.")]
    InconsistentPublicKey(PublicKeyHash),
    #[error("Could not retrieve manager.")]
    UnretrievableManager,
    #[error("Failed to write manager.")]
    FailedToWriteManager,
}

#[derive(thiserror::Error, Debug, PartialEq, Eq, BinWriter, NomReader)]
#[error("{contract:?} cannot spend {amount:?} as its balance is {balance:?}")]
pub struct BalanceTooLow {
    pub contract: Contract,
    pub balance: Narith,
    pub amount: Narith,
}

#[derive(Error, Debug, PartialEq, Eq, BinWriter, NomReader)]
pub enum TransferError {
    #[error(transparent)]
    BalanceTooLow(BalanceTooLow),
    #[error("{0:?} is unspendable")]
    UnspendableContract(Contract),
    #[error("Called a non-smart contract with parameter")]
    NonSmartContractExecutionCall,
    // TODO: #8003 propagate the error generated by MIR
    #[error("Apply operation failed because of micheline decoding {0}")]
    MichelineDecodeError(String),
    // TODO: #8003 propagate the error generated by MIR
    #[error("Failed interpreting the Michelson contract with {0}")]
    MichelsonContractInterpretError(String),
    // TODO: #8003 propagate the error generated by MIR
    #[error("Mir failed to typecheck the contract with {0}")]
    MirTypecheckingError(String),
    #[error("Failed to allocate destination")]
    FailedToAllocateDestination,
    #[error("Failed to compute balance update due to new balance overflow")]
    FailedToComputeBalanceUpdate,
    #[error("Failed to apply balance changes")]
    FailedToApplyBalanceChanges,
    #[error("Failed to fetch destination account")]
    FailedToFetchDestinationAccount,
    #[error("Failed to fetch contract code")]
    FailedToFetchContractCode,
    #[error("Failed to fetch contract storage")]
    FailedToFetchContractStorage,
    #[error("Failed to fetch destination balance")]
    FailedToFetchDestinationBalance,
    #[error("Failed to fetch sender balance")]
    FailedToFetchSenderBalance,
    #[error("Failed to update contract storage")]
    FailedToUpdateContractStorage,
    #[error("Failed to update destination balance")]
    FailedToUpdateDestinationBalance,
    #[error("Apply operation failed because of an unsupported address error")]
    MirAddressUnsupportedError,
    #[error("Failed to execute internal operation: {0}")]
    FailedToExecuteInternalOperation(String),
    #[error("Failed to convert amount to Narith: {0}")]
    MirAmountToNarithError(String),
    #[error("Failed to convert Narith to amount: {0}")]
    MirNarithToAmountError(String),
}

#[derive(Error, Debug, PartialEq, Eq, NomReader)]
pub enum OriginationError {
    #[error("Failed to fetch originated smart contract")]
    FailedToFetchOriginated,
    #[error("Failed to compute balance update")]
    FailedToComputeBalanceUpdate,
    #[error("Failed to applied balance update")]
    FailedToApplyBalanceUpdate,
    #[error("Can't initialize smart contract")]
    CantInitContract,
    #[error("Can't originate an empty smart contract")]
    CantOriginateEmptyContract,
    #[error("Mir failed to typecheck the contract with {0}")]
    MirTypecheckingError(String),
    #[error("Failed because of micheline decoding {0}")]
    MichelineDecodeError(String),
}

impl From<mir::serializer::DecodeError> for TransferError {
    fn from(err: mir::serializer::DecodeError) -> Self {
        Self::MichelineDecodeError(err.to_string())
    }
}

impl From<mir::interpreter::ContractInterpretError<'_>> for TransferError {
    fn from(err: mir::interpreter::ContractInterpretError) -> Self {
        Self::MichelsonContractInterpretError(err.to_string())
    }
}

impl From<mir::typechecker::TcError> for TransferError {
    fn from(err: mir::typechecker::TcError) -> Self {
        Self::MirTypecheckingError(err.to_string())
    }
}

#[derive(Error, Debug, PartialEq, Eq, NomReader)]
pub enum ApplyOperationError {
    #[error("Reveal error: {0}")]
    Reveal(#[from] RevealError),
    #[error("Transfer error: {0}")]
    Transfer(#[from] TransferError),
    #[error("Origination error: {0}")]
    Origination(#[from] OriginationError),
    #[error("Smart-Contract emitted an event, which is unsupported: {0}")]
    UnSupportedEmit(String),
    #[error("Set delegate operation is unsupported: {0}")]
    UnSupportedSetDelegate(String),
    #[error("Internal operation nonce overflow due to {0}")]
    InternalOperationNonceOverflow(String),
}

#[derive(Error, Debug, PartialEq, Eq)]
pub enum OperationError {
    #[error("Validation error: {0}")]
    Validation(#[from] ValidityError),
    #[error("Runtime error: {0}")]
    RuntimeError(#[from] RuntimeError),
}

#[allow(dead_code)]
fn elements_to_bson(elts: &[(&[u8], &[u8])]) -> Vec<u8> {
    // As per the BSON specification (https://bsonspec.org/spec.html), the BSON
    // document is made of the concatenation of the following values:
    //   * its full size encoded on 4 little-endian bytes, including
    //     the size itself;
    //   * its concatenated fields (the contents of the document);
    //   * the byte 0.

    let mut document = vec![];
    let mut contents = vec![];
    for (key, value) in elts {
        // Tag 2 for a field of type string.
        contents.push(0x02);
        // The key does not require a size prefix.
        contents.extend_from_slice(key);
        // The 0 byte terminates the key.
        contents.push(0x00);
        // The value is also suffixed by the 0 byte and contrary to the key it is
        // prefixed by its size (including the 0 byte, hence the + 1).
        contents.extend_from_slice(&(value.len() as u32 + 1).to_le_bytes());
        contents.extend_from_slice(value);
        contents.push(0x00);
    }

    // The size here is the size of the whole document, including the trailing 0
    // byte and the 4 bytes used to represent the size itself (hence the + 5).
    document.extend_from_slice(&(contents.len() as u32 + 5).to_le_bytes());
    document.extend_from_slice(&contents);
    document.push(0x00);
    document
}

// In Tezos data encoding, errors are encoded as bson (binary json). Unfortunately,
// we cannot use the rust binary json crate to produce compatible bson data because
// this crate uses Float pointer instructions (which is incompatible with the PVM).
// To avoid reimplementing full bson support, we convert errors to strings and
// manually encode them in bson. This gives us error which can be decoded using
// Tezos data encoding but with less structure than what Tezos L1 produces.
impl BinWriter for ApplyOperationError {
    fn bin_write(&self, output: &mut Vec<u8>) -> tezos_enc::BinResult {
        tezos_enc::dynamic(|error, out: &mut Vec<u8>| {
            // Convert the error to a String
            let error = format!("{error:?}");
            let encoded_error = error.as_bytes();
            let size_of_string: u32 = encoded_error
                .len()
                .try_into()
                .map_err(|err| tezos_enc::BinError::custom(format!("{err}")))?;
            // Tag for a BSON string is 0x82 (1 byte)
            let bson_tag_size = 1;
            // Size of a BSON object is encoded on 4 bytes
            let bson_size = 4;
            // Size of a BSON string is encoded on 4 bytes
            let bson_string_size = 4;
            // Tag for BSON string termination is on 1 byte
            let bson_string_end_tag_size = 1;
            // Tag for BSON termination is on 1 byte
            let bson_end_tag_size = 1;
            // A BSON object starts with its size
            let mut bson = (bson_tag_size
                + bson_size
                + bson_string_size
                + size_of_string
                + bson_string_end_tag_size
                + bson_end_tag_size)
                .to_le_bytes()
                .to_vec();
            // In BSON, 0x82 is the tag for a String
            bson.push(0x82_u8);
            // In BSON, a String is encoded with its size on 4 bytes.
            // But also an end bytes (byte 0), this is why we encode
            // size + 1
            bson.extend_from_slice(
                &(size_of_string + bson_string_end_tag_size).to_le_bytes(),
            );
            bson.extend_from_slice(encoded_error);
            bson.push(0x00);
            // This is a little hack, but an OperationError will always be encoded in a list of OperationError.
            // This zero byte represent the end of an item. Doing this prevent to rewrite multiple BinWriter
            // implementation.
            bson.push(0x00);
            tezos_enc::bytes(bson, out)?;
            Ok(())
        })(self, output)
    }
}

// As we're encoding the OperationError with a single String, the NomReader function is broken.
// This is not an issue as we never deserialize OperationError outside of tests.
impl NomReader<'_> for OperationError {
    fn nom_read(input: &'_ [u8]) -> tezos_nom::NomResult<'_, Self> {
        Err(nom::Err::Error(DecodeError::from_error_kind(
            input,
            nom::error::ErrorKind::Fail,
        )))
    }
}

pub trait OperationKind {
    type Success: PartialEq + Debug + BinWriter + for<'a> NomReader<'a>;
}

impl OperationKind for TransferContent {
    type Success = TransferTarget;
}
impl OperationKind for RevealContent {
    type Success = RevealSuccess;
}

impl OperationKind for OriginationContent {
    type Success = OriginationSuccess;
}

// Inspired from `src/proto_alpha/lib_protocol/apply_results.ml` : transaction_contract_variant_cases
#[derive(PartialEq, Debug, NomReader, BinWriter)]
pub enum TransferTarget {
    ToContrat(TransferSuccess),
}

impl From<TransferSuccess> for TransferTarget {
    fn from(value: TransferSuccess) -> Self {
        TransferTarget::ToContrat(value)
    }
}

impl From<TransferTarget> for TransferSuccess {
    fn from(value: TransferTarget) -> Self {
        match value {
            TransferTarget::ToContrat(success) => success,
        }
    }
}

#[derive(PartialEq, Debug, NomReader, BinWriter)]
pub struct RevealSuccess {
    pub consumed_gas: Narith,
}

// PlaceHolder Type for temporary unused fields
#[derive(PartialEq, Debug)]
pub struct Empty;

impl BinWriter for Empty {
    fn bin_write(&self, _: &mut Vec<u8>) -> tezos_enc::BinResult {
        Ok(())
    }
}

impl NomReader<'_> for Empty {
    fn nom_read(input: &'_ [u8]) -> tezos_nom::NomResult<'_, Self> {
        Ok((input, Self))
    }
}

// alpha.contract_id.originated (22 bytes, 8-bit tag)
// **************************************************
//
// Originated (tag 1)
// ==================
//
// +---------------+----------+------------------------+
// | Name          | Size     | Contents               |
// +===============+==========+========================+
// | Tag           | 1 byte   | unsigned 8-bit integer |
// +---------------+----------+------------------------+
// | Contract_hash | 20 bytes | bytes                  |
// +---------------+----------+------------------------+
// | padding       | 1 byte   | padding                |
// +---------------+----------+------------------------+
//
// The encoding of the alpha.contract_id.originated type is the same as
// the one implemented in the kernel_sdk Contract. However, this type
// cannot be an implicit account. Therefore, we created a new type that
// only holds a KT1. The new type reuses the existing functions.
#[derive(PartialEq, Debug)]
pub struct Originated {
    pub contract: ContractKt1Hash,
}

impl BinWriter for Originated {
    fn bin_write(&self, output: &mut Vec<u8>) -> tezos_enc::BinResult {
        let contract = Contract::Originated(self.contract.clone());
        contract.bin_write(output)
    }
}

impl NomReader<'_> for Originated {
    fn nom_read(input: &'_ [u8]) -> tezos_nom::NomResult<'_, Self> {
        let (input, contract) = Contract::nom_read(input)?;
        match contract {
            Contract::Originated(kt1h) => Ok((input, Originated { contract: kt1h })),
            Contract::Implicit(_) => Err(nom::Err::Error(DecodeError::from_error_kind(
                input,
                nom::error::ErrorKind::Fail,
            ))),
        }
    }
}

// Inspired of src/proto_023_PtSeouLo/lib_protocol/apply_internal_result.mli
#[derive(PartialEq, Debug, BinWriter, NomReader)]
pub struct OriginationSuccess {
    #[encoding(dynamic, list)]
    pub balance_updates: Vec<BalanceUpdate>,
    #[encoding(dynamic, list)]
    pub originated_contracts: Vec<Originated>,
    pub consumed_gas: Narith,
    pub storage_size: Zarith,
    pub paid_storage_size_diff: Zarith,
    // TODO: Placeholder for lazy storage diff issue : #8018
    pub lazy_storage_diff: Option<()>,
}

#[derive(PartialEq, Debug, BinWriter, NomReader)]
pub struct TransferSuccess {
    pub storage: Option<Vec<u8>>,
    #[encoding(dynamic, list)]
    pub balance_updates: Vec<BalanceUpdate>,
    // TODO: Placeholder for ticket receipt issue : #8018
    #[encoding(dynamic, bytes)]
    pub ticket_receipt: Vec<u8>,
    // TODO: Placeholder for originated contracts issue : #8018
    #[encoding(dynamic, bytes)]
    pub originated_contracts: Vec<u8>,
    pub consumed_gas: Narith,
    pub storage_size: Zarith,
    pub paid_storage_size_diff: Zarith,
    pub allocated_destination_contract: bool,
    // TODO: Placeholder for lazy storage diff issue : #8018
    pub lazy_storage_diff: Option<()>,
}

// An operation error in a Tezos receipt has no specific format
// It should just be encoded as a JSON, so we can't derive
// NomReader and BinWriter if we want to be Tezos compatible
#[derive(PartialEq, Debug, BinWriter, NomReader)]
pub struct ApplyOperationErrors {
    #[encoding(dynamic, list)]
    pub errors: Vec<ApplyOperationError>,
}

impl From<Vec<ApplyOperationError>> for ApplyOperationErrors {
    fn from(value: Vec<ApplyOperationError>) -> Self {
        ApplyOperationErrors { errors: value }
    }
}

impl From<ApplyOperationError> for ApplyOperationErrors {
    fn from(value: ApplyOperationError) -> Self {
        ApplyOperationErrors {
            errors: vec![value],
        }
    }
}

// Inspired from `operation_result` in `src/proto_alpha/lib_protocol/apply_operation_result.ml`
// Still need to implement Backtracked and Skipped
#[derive(PartialEq, Debug, BinWriter, NomReader)]
pub enum ContentResult<M: OperationKind> {
    Applied(M::Success),
    Failed(ApplyOperationErrors),
    Skipped,
    BackTracked(M::Success),
}

impl<M: OperationKind> ContentResult<M> {
    pub fn backtrack_if_applied(&mut self) {
        if let ContentResult::Applied(_) = self {
            // Lowkey optimisation: takes the ownership of the content result by replacing
            // the result with Skipped as a place holder
            let current_content_result = std::mem::replace(self, ContentResult::Skipped);
            if let ContentResult::Applied(success) = current_content_result {
                *self = ContentResult::BackTracked(success);
            }
        }
    }
}

/// A [Balance] updates can be triggered on different target
/// inspired from src/proto_alpha/lib_protocol/receipt_repr.ml
#[derive(PartialEq, Debug, NomReader, BinWriter)]
#[encoding(tags = "u8")]
pub enum Balance {
    #[encoding(tag = 0)]
    Account(Contract),
    // Don't know why but in balance_and_update in receipt_repr.ml,
    // the tag 1 doesn't exist
    #[encoding(tag = 2)]
    BlockFees,
    #[encoding(tag = 11)]
    StorageFees,
}

/// Inspired from update_origin_encoding src/proto_alpha/lib_protocol/receipt_repr.ml
#[derive(PartialEq, Debug, NomReader, BinWriter)]
pub enum UpdateOrigin {
    BlockApplication,
}

/// Depending of the sign of [changes], the balance is credited or debited
/// Inspired from balance_updates_encoding src/proto_alpha/lib_protocol/receipt_repr.ml
#[derive(PartialEq, Debug, NomReader, BinWriter)]
pub struct BalanceUpdate {
    pub balance: Balance,
    pub changes: i64,
    pub update_origin: UpdateOrigin,
}

// Inspired from `Manager_operation_result` case in 'kind contents_result type
// from `src/proto_alpha/lib_protocol/apply_results.ml` file.
// Still need to implement internal_results
#[derive(PartialEq, Debug, NomReader, BinWriter)]
pub struct OperationResult<M: OperationKind> {
    #[encoding(dynamic, list)]
    pub balance_updates: Vec<BalanceUpdate>,
    pub result: ContentResult<M>,
    //TODO Placeholder for internal operations : #8018
    #[encoding(dynamic, list)]
    pub internal_operation_results: Vec<InternalOperationSum>,
}

#[derive(PartialEq, Debug, BinWriter, NomReader)]
pub struct InternalContentWithMetadata<M: OperationKind> {
    pub sender: Contract,
    pub nonce: u16,
    pub content: M,
    pub result: ContentResult<M>,
}

#[derive(PartialEq, Debug, NomReader, BinWriter)]
pub enum InternalOperationSum {
    #[encoding(tag = 1)]
    Transfer(InternalContentWithMetadata<TransferContent>),
    #[encoding(tag = 2)]
    Origination(InternalContentWithMetadata<OriginationContent>),
}

impl InternalOperationSum {
    pub fn transform_result_backtrack(&mut self) {
        match self {
            InternalOperationSum::Transfer(op_res) => {
                op_res.result.backtrack_if_applied();
            }
            InternalOperationSum::Origination(op_res) => {
                op_res.result.backtrack_if_applied();
            }
        }
    }
    pub fn is_applied(&self) -> bool {
        match self {
            InternalOperationSum::Transfer(op_res) => {
                matches!(op_res.result, ContentResult::Applied(_))
            }
            InternalOperationSum::Origination(op_res) => {
                matches!(op_res.result, ContentResult::Applied(_))
            }
        }
    }
}

#[derive(PartialEq, Debug)]
pub enum OperationResultSum {
    Reveal(OperationResult<RevealContent>),
    Transfer(OperationResult<TransferContent>),
    Origination(OperationResult<OriginationContent>),
}

impl OperationResultSum {
    pub fn is_applied(&self) -> bool {
        match self {
            OperationResultSum::Reveal(op_res) => {
                matches!(op_res.result, ContentResult::Applied(_))
            }
            OperationResultSum::Transfer(op_res) => {
                matches!(op_res.result, ContentResult::Applied(_))
            }
            OperationResultSum::Origination(op_res) => {
                matches!(op_res.result, ContentResult::Applied(_))
            }
        }
    }

    pub fn transform_result_backtrack(&mut self) {
        match self {
            OperationResultSum::Transfer(op_result) => {
                op_result.result.backtrack_if_applied();
            }
            OperationResultSum::Reveal(op_result) => {
                op_result.result.backtrack_if_applied();
            }
            OperationResultSum::Origination(op_result) => {
                op_result.result.backtrack_if_applied();
            }
        }
    }
}

pub fn produce_operation_result<M: OperationKind>(
    balance_updates: Vec<BalanceUpdate>,
    result: Result<M::Success, ApplyOperationError>,
    internal_operation_results: Vec<InternalOperationSum>,
) -> OperationResult<M> {
    match result {
        Ok(success) => {
            let all_internal_succeded = internal_operation_results
                .last()
                .is_none_or(InternalOperationSum::is_applied);
            OperationResult {
                balance_updates,
                result: if all_internal_succeded {
                    ContentResult::Applied(success)
                } else {
                    ContentResult::BackTracked(
                        success, // If internal operations failed, we backtrack the main operation result
                    )
                },
                internal_operation_results,
            }
        }
        Err(operation_error) => OperationResult {
            balance_updates,
            result: ContentResult::Failed(vec![operation_error].into()),
            internal_operation_results,
        },
    }
}

pub fn produce_skipped_receipt(
    op: &ManagerOperation<OperationContent>,
) -> OperationResultSum {
    match op.operation {
        OperationContent::Reveal(_) => {
            OperationResultSum::Reveal(produce_skipped_result())
        }
        OperationContent::Transfer(_) => {
            OperationResultSum::Transfer(produce_skipped_result())
        }
        OperationContent::Origination(_) => {
            OperationResultSum::Origination(produce_skipped_result())
        }
    }
}

fn produce_skipped_result<M: OperationKind>() -> OperationResult<M> {
    OperationResult {
        balance_updates: vec![],
        result: ContentResult::Skipped,
        internal_operation_results: vec![],
    }
}

#[derive(PartialEq, Debug, NomReader, BinWriter)]
pub enum OperationDataAndMetadata {
    OperationWithMetadata(OperationBatchWithMetadata),
}

#[derive(PartialEq, Debug, NomReader, BinWriter)]
pub struct OperationBatchWithMetadata {
    #[encoding(dynamic, list)]
    pub operations: Vec<OperationWithMetadata>,
    pub signature: UnknownSignature,
}

#[derive(PartialEq, Debug)]
pub struct OperationWithMetadata {
    pub content: ManagerOperationContent,
    pub receipt: OperationResultSum,
}

impl NomReader<'_> for OperationWithMetadata {
    fn nom_read(input: &'_ [u8]) -> tezos_nom::NomResult<'_, Self> {
        let (input, content) = ManagerOperationContent::nom_read(input)?;
        let (input, receipt) = match content {
            ManagerOperationContent::Transfer(_) => {
                let (input, receipt) =
                    OperationResult::<TransferContent>::nom_read(input)?;
                (input, OperationResultSum::Transfer(receipt))
            }
            ManagerOperationContent::Reveal(_) => {
                let (input, receipt) = OperationResult::<RevealContent>::nom_read(input)?;
                (input, OperationResultSum::Reveal(receipt))
            }
            ManagerOperationContent::Origination(_) => {
                let (input, receipt) =
                    OperationResult::<OriginationContent>::nom_read(input)?;
                (input, OperationResultSum::Origination(receipt))
            }
        };
        Ok((input, Self { content, receipt }))
    }
}

impl BinWriter for OperationWithMetadata {
    fn bin_write(&self, output: &mut Vec<u8>) -> tezos_enc::BinResult {
        self.content.bin_write(output)?;
        match &self.receipt {
            OperationResultSum::Transfer(receipt) => receipt.bin_write(output),
            OperationResultSum::Reveal(receipt) => receipt.bin_write(output),
            OperationResultSum::Origination(receipt) => receipt.bin_write(output),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::operation::{ManagerOperation, OriginationContent, TransferContent};
    use pretty_assertions::assert_eq;

    fn dummy_failed_operation() -> OperationDataAndMetadata {
        OperationDataAndMetadata::OperationWithMetadata (
                OperationBatchWithMetadata {
                    operations: vec![OperationWithMetadata {
                        content: ManagerOperationContent::Transfer(
                            ManagerOperation {
                                source: PublicKeyHash::from_b58check("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx").unwrap(),
                                fee: 255.into(),
                                counter: 1.into(),
                                gas_limit: 0.into(),
                                storage_limit: 0.into(),
                                operation: TransferContent {
                                    amount: 27942405962072064.into(),
                                    destination: Contract::from_b58check("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN").unwrap(),
                                    parameters: None,
                                }
                            }),
                        receipt: OperationResultSum::Transfer(
                                    OperationResult {
                                        balance_updates: vec![],
                                        result: ContentResult::Failed(
                                            vec![
                                                    ApplyOperationError::Transfer(
                                                        TransferError::BalanceTooLow(
                                                            BalanceTooLow {
                                                                contract: Contract::from_b58check("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx").unwrap(),
                                                                balance: 10_u64.into(),
                                                                amount: 21_u64.into()
                                                            }
                                                        )
                                                    ),
                                                    ApplyOperationError::Transfer(
                                                        TransferError::BalanceTooLow(
                                                            BalanceTooLow {
                                                                contract: Contract::from_b58check("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN").unwrap(),
                                                                balance: 55_u64.into(),
                                                                amount: 1111_u64.into()
                                                            }
                                                        )
                                                    )
                                                ].into()),
                                        internal_operation_results: vec![]
                                    }
                                )
                    }],
                    signature:  UnknownSignature::from_base58_check(
                       "sigvVF2FguUHvZHytQ4AoRn4R6tSMteAt4nEHfYEbwQi3nXa3xvsgE93V1XYL99FYFUAH83iSpcAe7KxGaAeE1tLJ3M2jGJT"
                    ).unwrap(),
                }
            )
    }

    fn dummy_test_result_operation() -> OperationDataAndMetadata {
        OperationDataAndMetadata::OperationWithMetadata (
                 OperationBatchWithMetadata {
                    operations: vec![OperationWithMetadata {
                        content: ManagerOperationContent::Transfer(ManagerOperation { source: PublicKeyHash::from_b58check("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx").unwrap(), fee: 468.into(), counter: 1.into(), gas_limit: 2169.into(), storage_limit: 0.into(), operation: TransferContent {
                            amount: 42000000.into(),
                            destination: Contract::from_b58check("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN").unwrap(),
                            parameters: None,
                        } }),
                        receipt: OperationResultSum::Transfer(OperationResult { balance_updates: vec![], result: ContentResult::Applied(
                            TransferTarget::ToContrat(
                            TransferSuccess { storage: None, lazy_storage_diff: None, balance_updates: vec![
                            BalanceUpdate { balance: Balance::Account(Contract::Implicit(PublicKeyHash::from_b58check("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx").unwrap())), changes: -42000000,update_origin : UpdateOrigin::BlockApplication },
                            BalanceUpdate { balance: Balance::Account(Contract::Implicit(PublicKeyHash::from_b58check("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN").unwrap())), changes: 42000000,update_origin : UpdateOrigin::BlockApplication}
                            ], ticket_receipt: vec![], originated_contracts: vec![], consumed_gas: 2169000.into(), storage_size: 0.into(), paid_storage_size_diff: 0.into(), allocated_destination_contract: false }
                            ))

                        , internal_operation_results: vec![] })
                    }],
                    signature:  UnknownSignature::from_base58_check(
                        "sigPc9gwEse2o5nsicnNeWLjLgoMbEGumXw7PErAkMMa1asXVKRq43RPd7TnUKYwuHmejxEu15XTyV1iKGiaa8akFHK7CCEF"
                    ).unwrap(),
                })
    }

    fn simple_origination_operation() -> OperationDataAndMetadata {
        OperationDataAndMetadata::OperationWithMetadata(
            OperationBatchWithMetadata {
               operations: vec![OperationWithMetadata {
                   content: ManagerOperationContent::Origination(ManagerOperation { source: PublicKeyHash::from_b58check("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx").unwrap(), fee: 343.into(), counter: 1.into(), gas_limit: 679.into(), storage_limit: 323.into(),
                   operation: OriginationContent {
                    balance: 1000000_u64.into(),
                    delegate: None,
                    /*
                    octez-client convert script "
                              parameter string;
                              storage string;
                              code { CAR; NIL operation; PAIR }
                            " from Michelson to binary
                     */
                    script: crate::operation::Script { code: hex::decode(
                        "02000000170500036805010368050202000000080316053d036d0342",
                    )
                    .unwrap(), storage: hex::decode(
                        "010000000568656c6c6f",
                    )
                    .unwrap() } } }),
                   receipt:
                    OperationResultSum::Origination(
                        OperationResult {
                            balance_updates:vec![BalanceUpdate { balance: Balance::Account(Contract::from_b58check("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx").unwrap()) , changes: -343, update_origin: UpdateOrigin::BlockApplication }, BalanceUpdate { balance: Balance::BlockFees , changes: 343, update_origin: UpdateOrigin::BlockApplication }],
                            result: ContentResult::Applied(
                                OriginationSuccess{
                                    balance_updates:vec![
                                        BalanceUpdate { balance: Balance::Account(Contract::from_b58check("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx").unwrap()) , changes: -11500, update_origin: UpdateOrigin::BlockApplication },
                                        BalanceUpdate { balance: Balance::StorageFees, changes: 11500, update_origin: UpdateOrigin::BlockApplication },
                                        BalanceUpdate { balance: Balance::Account(Contract::from_b58check("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx").unwrap()) , changes: -64250, update_origin: UpdateOrigin::BlockApplication },
                                        BalanceUpdate { balance: Balance::StorageFees, changes: 64250, update_origin: UpdateOrigin::BlockApplication },
                                        BalanceUpdate { balance: Balance::Account(Contract::from_b58check("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx").unwrap()) , changes: -1000000, update_origin: UpdateOrigin::BlockApplication },
                                        BalanceUpdate { balance: Balance::Account(Contract::from_b58check("KT1WcSvmiwJqDUm6cKEFjGVizXVSMujq5Kfe").unwrap()) , changes: 1000000, update_origin: UpdateOrigin::BlockApplication },
                                    ],
                                    originated_contracts:vec![Originated {contract: ContractKt1Hash::from_base58_check("KT1WcSvmiwJqDUm6cKEFjGVizXVSMujq5Kfe").unwrap()}],
                                    consumed_gas:578755_u64.into(),
                                    storage_size:46_u64.into(),
                                    paid_storage_size_diff:46_u64.into(),
                                    lazy_storage_diff: None,
                                }),
                            internal_operation_results: vec![]
                        })
                    }
               ],
               signature:  UnknownSignature::from_base58_check(
                   "sigjUkDaz4jjfp7EvsPGryCBoGKZ1B3FiAn4kX9adpwmcKUEpobhkNJjbYqjxB1mgBe7wGGGQp4T8MPzithFpbBMCN2L5RUa"
               ).unwrap(),
           })
    }

    #[test]
    fn test_operation_with_metadata_rlp_roundtrip() {
        let operation_and_receipt = dummy_test_result_operation();
        let mut output = vec![];
        operation_and_receipt
            .bin_write(&mut output)
            .expect("Operation with metadata should be encodable");
        let outputcpy = output.clone();
        let (remaining, read_result) = OperationDataAndMetadata::nom_read(&outputcpy)
            .expect("Operation with metadata should be decodable");

        assert_eq!(
            read_result, operation_and_receipt,
            "Roundtrip failed on {:?}",
            read_result
        );
        assert!(
            remaining.is_empty(),
            "There should be no remaining bytes after decoding"
        );
    }

    // The operation with metadata below is produced by using the following command:
    /* octez-codec encode 022-PsRiotum.operation.data_and_metadata from '{"contents":
    [{"kind":"transaction","source":"tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx",
      "fee":"468","counter":"1","gas_limit":"2169","storage_limit":"0",
      "amount":"42000000","destination":"tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN",
      "metadata":{"balance_updates":[],
      "operation_result":{"status":"applied",
      "balance_updates":[{"kind":"contract","contract":"tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx","change":"-42000000","origin":"block"},{"kind":"contract","contract":"tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN","change":"42000000","origin":"block"}],
      "consumed_milligas":"2169000"}}}],
      "signature":"sigPc9gwEse2o5nsicnNeWLjLgoMbEGumXw7PErAkMMa1asXVKRq43RPd7TnUKYwuHmejxEu15XTyV1iKGiaa8akFHK7CCEF"}' */
    #[test]
    fn tezos_compatibility_for_successful_operation_with_metadata() {
        let mut output = vec![];
        dummy_test_result_operation()
            .bin_write(output.as_mut())
            .expect("Operation with metadata should be encodable");
        let operation_and_receipt_bytes = "00000000966c0002298c03ed7d454a101eb7022bc95f7e5f41ac78d40301f9100080bd83140000e7670f32038107a59a2b9cfefae36ea21f5aa63c00000000000000000000004000000002298c03ed7d454a101eb7022bc95f7e5f41ac78fffffffffd7f218000000000e7670f32038107a59a2b9cfefae36ea21f5aa63c000000000280de80000000000000000000a8b1840100000000000000000c5e6f3021d6effcc1b99d918a3db6dd4820893f076386fb9c85bf62f497870936898e970901e5f8b3e41a8eb0aa1a578811c110415c01719e6ed2dc6e96bb0a";

        assert_eq!(hex::encode(output), operation_and_receipt_bytes);
    }

    // The operation with metadata below is produced by using the following command:
    /* octez-codec encode 023-PtSeouLo.operation.data_and_metadata from '{"contents":
    [{"kind":"origination","source":"tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx",
      "fee":"343","counter":"1","gas_limit":"679","storage_limit":"323",
      "balance":"1000000",
      "script":{"code":[
        {"prim":"parameter","args":[{"prim":"string"}]},
        {"prim":"storage","args":[{"prim":"string"}]},
        {"prim":"code","args":[[{"prim":"CAR"},{"prim":"NIL","args":[{"prim":"operation"}]},{"prim":"PAIR"}]]}],
      "storage":{"string":"hello"}},
      "metadata":
        {"balance_updates":[
        {"kind":"contract","contract":"tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx","change":"-343","origin":"block"},
        {"kind":"accumulator","category":"block fees","change":"343","origin":"block"}],
         "operation_result":{
            "status":"applied",
            "balance_updates":[{"kind":"contract","contract":"tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx","change":"-11500","origin":"block"},{"kind":"burned","category":"storage fees","change":"11500","origin":"block"},{"kind":"contract","contract":"tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx","change":"-64250","origin":"block"},{"kind":"burned","category":"storage fees","change":"64250","origin":"block"},{"kind":"contract","contract":"tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx","change":"-1000000","origin":"block"},{"kind":"contract","contract":"KT1WcSvmiwJqDUm6cKEFjGVizXVSMujq5Kfe","change":"1000000","origin":"block"}],
            "originated_contracts":["KT1WcSvmiwJqDUm6cKEFjGVizXVSMujq5Kfe"],
            "consumed_milligas":"578755",
            "storage_size":"46",
            "paid_storage_size_diff":"46"}}}],
            "signature":"sigjUkDaz4jjfp7EvsPGryCBoGKZ1B3FiAn4kX9adpwmcKUEpobhkNJjbYqjxB1mgBe7wGGGQp4T8MPzithFpbBMCN2L5RUa"}' */
    #[test]
    fn tezos_compatibility_for_successful_origination_with_metadata() {
        let mut output = vec![];
        simple_origination_operation()
            .bin_write(output.as_mut())
            .expect("Operation with metadata should be encodable");
        let operation_and_receipt_bytes = "000000013a6d0002298c03ed7d454a101eb7022bc95f7e5f41ac78d70201a705c302c0843d000000001c02000000170500036805010368050202000000080316053d036d03420000000a010000000568656c6c6f0000002a00000002298c03ed7d454a101eb7022bc95f7e5f41ac78fffffffffffffea90002000000000000015700000000009400000002298c03ed7d454a101eb7022bc95f7e5f41ac78ffffffffffffd314000b0000000000002cec0000000002298c03ed7d454a101eb7022bc95f7e5f41ac78ffffffffffff0506000b000000000000fafa0000000002298c03ed7d454a101eb7022bc95f7e5f41ac78fffffffffff0bdc0000001f1a40a8574cf5dd73ddaa5c3a4eabad41e64ae0b0000000000000f4240000000001601f1a40a8574cf5dd73ddaa5c3a4eabad41e64ae0b00c3a9232e2e0000000000a443d5393c979c3685198d8fb754bfd9bd59c4c96423fc3928cfcf9742921c7b0490057599fa9367cc74d6bcb5c0004adcf69037e655779642e1b94586544a00";

        assert_eq!(hex::encode(output), operation_and_receipt_bytes);
    }

    /*
        octez-codec encode alpha.operation.data_and_metadata from '{ "contents":
      [ { "kind": "transaction",
          "source": "tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx", "fee": "255",
          "counter": "1", "gas_limit": "0", "storage_limit": "0",
          "amount": "27942405962072064",
          "destination": "tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN",
          "metadata":
            { "operation_result":
                { "status": "failed",
                  "errors":
                    [ "Transfer(BalanceTooLow(BalanceTooLow { contract: Implicit(Ed25519(ContractTz1Hash(\"tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx\"))), balance: Narith(10), amount: Narith(21) }))",
                      "Transfer(BalanceTooLow(BalanceTooLow { contract: Implicit(Ed25519(ContractTz1Hash(\"tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN\"))), balance: Narith(55), amount: Narith(1111) }))" ] } } } ],
    "signature":
      "sigvVF2FguUHvZHytQ4AoRn4R6tSMteAt4nEHfYEbwQi3nXa3xvsgE93V1XYL99FYFUAH83iSpcAe7KxGaAeE1tLJ3M2jGJT" }'
         */
    #[test]
    fn tezos_compatibility_for_failed_operation_with_metadata() {
        let operation = dummy_failed_operation();
        let output = operation
            .to_bytes()
            .expect("Operation with metadata should be encodable");
        let operation_and_receipt_bytes = "00000001b76c0002298c03ed7d454a101eb7022bc95f7e5f41ac78ff010100008080a8ec85afd1310000e7670f32038107a59a2b9cfefae36ea21f5aa63c00000000000100000170000000b3b300000082a90000005472616e736665722842616c616e6365546f6f4c6f772842616c616e6365546f6f4c6f77207b20636f6e74726163743a20496d706c69636974284564323535313928436f6e7472616374547a31486173682822747a314b715470455a37596f62375162504534487934576f38664847384c684b785a5378222929292c2062616c616e63653a204e6172697468283130292c20616d6f756e743a204e617269746828323129207d29290000000000b5b500000082ab0000005472616e736665722842616c616e6365546f6f4c6f772842616c616e6365546f6f4c6f77207b20636f6e74726163743a20496d706c69636974284564323535313928436f6e7472616374547a31486173682822747a31676a614638315a525276647a6a6f627966564e7341655343365053636a6651774e222929292c2062616c616e63653a204e6172697468283535292c20616d6f756e743a204e6172697468283131313129207d2929000000000000f868f45f51a0c7a5733ab2c7f29781303904d9ef5b8fbf7b96429f00fe487c1d0f174c205b49c7393e5436b9522b88d3951113c32115e518465e029439874306";

        assert_eq!(hex::encode(output), operation_and_receipt_bytes);
    }

    /*
    octez-codec encode alpha.operation.internal_and_metadata from '{
      "kind": "transaction",
      "source": "tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb",
      "nonce": 0,
      "amount": "1000000",
      "destination": "KT1RJ6PbjHpwc3M5rw5s2Nbmefwbuwbdxton",
      "result": {
        "status": "applied",
        "consumed_milligas": "100000",
        "storage_size": "0",
        "paid_storage_size_diff": "0",
        "balance_updates": [
          {
            "kind": "contract",
            "contract": "tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb",
            "change": "-1000000",
            "origin": "block"
          },
          {
            "kind": "contract",
            "contract": "KT1RJ6PbjHpwc3M5rw5s2Nbmefwbuwbdxton",
            "change": "1000000",
            "origin": "block"
          }
        ]
      }
    }'
    */
    #[test]
    fn tezos_compatibility_for_internal_operation_with_metadata() {
        let operation = InternalOperationSum::Transfer(InternalContentWithMetadata {
            content: TransferContent {
                amount: 1000000.into(),
                destination: Contract::from_b58check(
                    "KT1RJ6PbjHpwc3M5rw5s2Nbmefwbuwbdxton",
                )
                .unwrap(),
                parameters: None,
            },
            sender: Contract::from_b58check("tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb")
                .unwrap(),
            nonce: 0,
            result: ContentResult::Applied(TransferTarget::ToContrat(TransferSuccess {
                storage: None,
                lazy_storage_diff: None,
                balance_updates: vec![
                    BalanceUpdate {
                        balance: Balance::Account(
                            Contract::from_b58check(
                                "tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb",
                            )
                            .unwrap(),
                        ),
                        changes: -1000000,
                        update_origin: UpdateOrigin::BlockApplication,
                    },
                    BalanceUpdate {
                        balance: Balance::Account(
                            Contract::from_b58check(
                                "KT1RJ6PbjHpwc3M5rw5s2Nbmefwbuwbdxton",
                            )
                            .unwrap(),
                        ),
                        changes: 1000000,
                        update_origin: UpdateOrigin::BlockApplication,
                    },
                ],
                ticket_receipt: vec![],
                originated_contracts: vec![],
                consumed_gas: 100000.into(),
                storage_size: 0.into(),
                paid_storage_size_diff: 0.into(),
                allocated_destination_contract: false,
            })),
        });
        let output = operation
            .to_bytes()
            .expect("Internal operation with metadata should be encodable");
        let operation_and_receipt_bytes = "0100006b82198cb179e8306c1bedd08f12dc863f3288860000c0843d01b752c7f3de31759bce246416a6823e86b9756c6c0000000000000000400000006b82198cb179e8306c1bedd08f12dc863f328886fffffffffff0bdc0000001b752c7f3de31759bce246416a6823e86b9756c6c0000000000000f4240000000000000000000a08d0600000000";
        assert_eq!(hex::encode(output), operation_and_receipt_bytes);
    }
}
